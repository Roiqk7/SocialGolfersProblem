from globals import *
import itertools
import math
from pathlib import Path

class ProblemInstance:
	def __init__(self, N: int, G: int, S: int, R: int, T: int):
		logger.debug("Began creating the problem instance...")
		self._Init(N, G, S, R, T)
		self._InitOutputFile()
		self._EncodeClauses()
		logger.debug("Finished creating the problem instance.")

	def _Init(self, N: int, G: int, S: int, R: int, T: int, InputFile: Path = None):
		self.N = N
		self.G = G
		self.S = S
		self.R = R
		self.T = T
		if InputFile is None:
			self.OutputFile = DEFAULT_CNF_FILE_PATH
		else:
			self.OutputFile = InputFile

	def _InitOutputFile(self):
		with open(self.OutputFile, "w") as f:
			f.write(f"c Social Golfers Problem CNF generated by https://github.com/Roiqk7/SocialGolfersProblem.git\n")
			# TODO: Check that the numbers are correct
			numVars, numClauses = self._GetNumberOfVariables(), self._GetNumberOfClauses()
			logger.info(f"The CNF encoding contains {numVars} variables and {numClauses} clauses.")
			f.write(f"p cnf {numVars} {numClauses}\n")

	def _EncodeClauses(self):
		logger.debug("Encoding clauses...")
		self._EncodeGroupPartitionConstraint()
		self._EncodeGroupSizeConstraint()
		self._EncodeDefinitionOfZ()
		self._EncodePairingConstraint()
		logger.debug("Finished encoding clauses.")

	def _GetXVarID(self, r, p, g) -> int:
		return r * (self.N * self.G) + p * self.G + g

	def _GetPairIndex(self, p1, p2) -> int:
		# We ensure p1 < p2
		if p1 > p2:
			p1, p2 = p2, p1

		return math.comb(p2, 2) + p1

	def _GetZVarID(self, r, p1, p2, g) -> int:
		return (self._GetNumberOfXVariables()
			+ r * (math.comb(self.N, 2) * self.G) + self._GetPairIndex(p1, p2) + g)

	def _GetNumberOfVariables(self) -> int:
		return (self._GetNumberOfXVariables()
			+ self._GetNumberOfZVariables())

	def _GetNumberOfXVariables(self) -> int:
		return self.N * self.G * self.R

	def _GetNumberOfZVariables(self) -> int:
		return self.R * math.comb(self.N, 2) * self.G

	def _GetClause(self, arr: list[int]) -> str:
		return " ".join(str(x) for x in arr) + " 0\n"

	def _WriteClause(self, arr: list[int]) -> None:
		with open(self.OutputFile, "a") as f:
			f.write(self._GetClause(arr))

	def _GetNumberOfClauses(self) -> int:
		return (self._GetGroupPartitionClauseCount()
			+ self._GetGroupSizeClauseCount()
			+ self._GetZDefinitionClauseCount()
			+ self._GetPairingClauseCount())

	def _GetGroupPartitionClauseCount(self) -> int:
		return self.R * self.N * (1 + math.comb(self.G, 2))

	def _GetGroupSizeClauseCount(self) -> int:
		return self.R * self.G * math.comb(self.N, self.S + 1)

	def _GetZDefinitionClauseCount(self) -> int:
		return 3 * self.R * self.G * math.comb(self.N, 2)

	def _GetPairingClauseCount(self) -> int:
		return math.comb(self.N, 2) * math.comb(self.R * self.G, self.T + 1)

	def _EncodeGroupPartitionConstraint(self):
		logger.debug("Encoding group partition constraints...")
		for r in range(self.R):
			for p in range(self.N):
				Xvars = [self._GetXVarID(r, p, g) for g in range(self.G)]
				# At least one - trivially just write the vars
				self._WriteClause(Xvars)
				# At most one - use helper
				self._EncodeAtMostKConstraint(Xvars, 1)
		logger.debug("Finished encoding group partition constraints.")

	def _EncodeGroupSizeConstraint(self):
		logger.debug("Encoding group size constraints...")
		for r in range(self.R):
			for g in range(self.G):
				Xvars = [self._GetXVarID(r, p, g) for p in range(self.N)]
				self._EncodeAtMostKConstraint(Xvars, self.S)
		logger.debug("Finished encoding group size constraints.")

	def _EncodeDefinitionOfZ(self):
		logger.debug("Encoding definition of Z...")
		for r in range(self.R):
			for g in range(self.G):
				for p1 in range(self.N):
					for p2 in range(p1 + 1, self.N):
						# Z <=> X1 and X2
						Xp1 = self._GetXVarID(r, p1, g)
						Xp2 = self._GetXVarID(r, p2, g)
						Z = self._GetZVarID(r, p1, p2, g)
						# 1. (Z -> Xp1)
						self._WriteClause([-Z, Xp1])
						# 2. (Z -> Xp2)
						self._WriteClause([-Z, Xp2])
						# 3. (Xp1 AND Xp2 -> Z)
						self._WriteClause([-Xp1, -Xp2, Z])
		logger.debug("Finished encoding definition of Z.")

	def _EncodePairingConstraint(self):
		logger.debug("Encoding pairing 'At Most T' constraints...")
		for p1 in range(self.N):
			for p2 in range(p1 + 1, self.N):
				ZvarsForPair = []
				for r in range(self.R):
					for g in range(self.G):
						ZvarsForPair.append(self._GetZVarID(r, p1, p2, g))
				self._EncodeAtMostKConstraint(ZvarsForPair, self.T)
		logger.debug("Finished encoding pairing 'At Most T' constraints.")

	def _EncodeAtMostKConstraint(self, variables: list[int], K: int):
		# Trivial case
		if len(variables) <= K:
			return

		# The constraint "At Most K are True" is equivalent to:
		# It is NOT True that > K + 1 are True.
		for combo in itertools.combinations(variables, K + 1):
			# For each combination of K + 1 variables, create a clause that forces
			# at least one of them to be False (i.e., negate all K+1 variables).
			clause = [-var for var in combo]
			self._WriteClause(clause)
