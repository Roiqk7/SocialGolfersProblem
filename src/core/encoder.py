from globals import *
from pathlib import Path
from time import perf_counter as clock
import itertools
import os

class ProblemInstance:
	def __init__(self, N: int, G: int, S: int, R: int, T: int):
		startTime = clock()
		logger.debug("Began creating the problem instance...")
		self._Init(N, G, S, R, T)
		self._EncodeClauses()
		self._FillOutputFile()
		self._WriteVarID()
		logger.debug(f"Finished creating the problem instance in {(clock() - startTime):.3f}.")

	def _Init(self, N: int, G: int, S: int, R: int, T: int, InputFile: Path = None):
		self.N = N
		self.G = G
		self.S = S
		self.R = R
		self.T = T
		self._VarIDMap = {}
		self._NextID = 1
		self._ClauseCount = 0
		self._TmpOutputFile = DEFAULT_TMP_CNF_FILE_PATH
		if os.path.exists(self._TmpOutputFile):
			os.remove(self._TmpOutputFile)
		self._VarIDMapFilePath = VAR_ID_FILE_PATH
		if os.path.exists(self._VarIDMapFilePath):
			os.remove(self._VarIDMapFilePath)
		if InputFile is None:
			self.OutputFile = DEFAULT_CNF_FILE_PATH
		else:
			self.OutputFile = InputFile

	def _FillOutputFile(self):
		with open(self.OutputFile, "w") as oF:
			numVars, numClauses = self._GetNumberOfVariables(), self._GetNumberOfClauses()
			logger.info(f"The CNF encoding contains {numVars} variables and {numClauses} clauses.")
			logger.info(f"Writing CNF to output file: {self.OutputFile}")
			oF.write(f"c Social Golfers Problem CNF generated by https://github.com/Roiqk7/SocialGolfersProblem.git\n")
			oF.write(f"p cnf {numVars} {numClauses}\n")
			with open(self._TmpOutputFile, "r") as tmpF:
				oF.write(tmpF.read())

	def _WriteVarID(self):
		logger.info(f"Writing variables to file: {self._VarIDMapFilePath}")
		# We filter Xes and sort them by id for easier processing later
		xVarItems = [(k, v) for k, v in self._VarIDMap.items() if k[0] == 'X']
		sortedXVarItems = sorted(xVarItems, key=lambda x: x[1])
		with open(self._VarIDMapFilePath, "w") as f:
			for k, id in sortedXVarItems:
				# format: id r p g
				_, r, p, g = k[0], k[1], k[2], k[3]
				f.write(f"{id} {r} {p} {g}\n")

	def _EncodeClauses(self):
		logger.debug("Encoding clauses...")
		self._EncodeGroupPartitionConstraint()
		self._EncodeGroupSizeConstraint()
		self._EncodeDefinitionOfZ()
		self._EncodePairingConstraint()
		logger.debug("Finished encoding clauses.")

	def _GetVarID(self, var: tuple):
		if var in self._VarIDMap:
			return self._VarIDMap[var]

		newID = self._NextID
		self._NextID += 1
		self._VarIDMap[var] = newID
		return newID

	def _GetNumberOfVariables(self) -> int:
		return self._NextID - 1

	def _GetNumberOfClauses(self) -> int:
		return self._ClauseCount

	def _GetClause(self, arr: list[int]) -> str:
		return " ".join(str(x) for x in arr) + " 0\n"

	def _WriteClause(self, arr: list[int]):
		self._ClauseCount += 1
		with open(self._TmpOutputFile, "a") as f:
			f.write(self._GetClause(arr))

	def _EncodeGroupPartitionConstraint(self):
		startTime = clock()
		clauseCount = self._ClauseCount
		logger.debug("Encoding group partition constraint...")
		for r in range(self.R):
			for p in range(self.N):
				Xvars = [self._GetVarID(('X', r, p, g)) for g in range(self.G)]
				# At least one - trivially just write the vars
				self._WriteClause(Xvars)
				# At most one - use helper
				self._EncodeAtMostKConstraint(Xvars, 1)
		logger.debug(f"Finished encoding group partition constraint in {(clock() - startTime):.3f} using {self._ClauseCount - clauseCount} clauses.")

	def _EncodeGroupSizeConstraint(self):
		startTime = clock()
		clauseCount = self._ClauseCount
		logger.debug("Encoding group size constraint...")
		for r in range(self.R):
			for g in range(self.G):
				Xvars = [self._GetVarID(('X', r, p, g)) for p in range(self.N)]
				self._EncodeAtMostKConstraint(Xvars, self.S)
		logger.debug(f"Finished encoding group size constraint in {(clock() - startTime):.3f} using {self._ClauseCount - clauseCount} clauses.")

	def _EncodeDefinitionOfZ(self):
		startTime = clock()
		clauseCount = self._ClauseCount
		logger.debug("Encoding definition of Z...")
		for r in range(self.R):
			for g in range(self.G):
				for p1 in range(self.N):
					for p2 in range(p1 + 1, self.N):
						# Z <=> X1 and X2
						Xp1 = self._GetVarID(('X', r, p1, g))
						Xp2 = self._GetVarID(('X', r, p2, g))
						Z = self._GetVarID(('Z', r, p1, p2, g))
						# 1. (Z -> Xp1)
						self._WriteClause([-Z, Xp1])
						# 2. (Z -> Xp2)
						self._WriteClause([-Z, Xp2])
						# 3. (Xp1 AND Xp2 -> Z)
						self._WriteClause([-Xp1, -Xp2, Z])
		logger.debug(f"Finished encoding definition of Z in {(clock() - startTime):.3f} using {self._ClauseCount - clauseCount} clauses.")

	def _EncodePairingConstraint(self):
		startTime = clock()
		clauseCount = self._ClauseCount
		logger.debug("Encoding pairing constraint...")
		for p1 in range(self.N):
			for p2 in range(p1 + 1, self.N):
				ZvarsForPair = []
				for r in range(self.R):
					for g in range(self.G):
						ZvarsForPair.append(self._GetVarID(('Z', r, p1, p2, g)))
				self._EncodeAtMostKConstraint(ZvarsForPair, self.T)
		logger.debug(f"Finished encoding pairing constraint in {(clock() - startTime):.3f} using {self._ClauseCount - clauseCount} clauses.")

	def _EncodeAtMostKConstraint(self, variables: list[int], K: int):
		# Trivial case
		if len(variables) <= K:
			return

		# The constraint "At Most K are True" is equivalent to:
		# It is NOT True that > K + 1 are True.
		for combo in itertools.combinations(variables, K + 1):
			# For each combination of K + 1 variables, create a clause that forces
			# at least one of them to be False (i.e., negate all K+1 variables).
			clause = [-var for var in combo]
			self._WriteClause(clause)
