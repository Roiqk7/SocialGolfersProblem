from globals import *
from pathlib import Path
from time import perf_counter as clock
import itertools
import os

class ProblemInstance:
	def __init__(self, N: int, G: int, S: int, R: int, T: int):
		try:
			startTime = clock()
			logger.debug("Began creating the problem instance...")
			self._Init(N, G, S, R, T)
			self._EncodeClauses()
			self._FillOutputFile()
			self._WriteVarID()
			logger.debug(f"Finished creating the problem instance in {(clock() - startTime):.3f}.")
		except Exception as e:
			logger.error(e)
			raise RuntimeError(f"Could not create the problem instance: {e}")

	def _Init(self, N: int, G: int, S: int, R: int, T: int, outputFile: Path = None):
		"""
		Initializes the problem instance.
		"""
		self.N = N
		self.G = G
		self.S = S
		self.R = R
		self.T = T
		self._VarIDMap = {}
		self._NextID = 1
		self._ClauseCount = 0
		self._TmpOutputFile = DEFAULT_TMP_CNF_FILE_PATH
		if os.path.exists(self._TmpOutputFile):
			os.remove(self._TmpOutputFile)
		self._VarIDMapFilePath = VAR_ID_FILE_PATH
		if os.path.exists(self._VarIDMapFilePath):
			os.remove(self._VarIDMapFilePath)
		if outputFile is None:
			self.OutputFile = DEFAULT_CNF_FILE_PATH
		else:
			self.OutputFile = outputFile

	def _FillOutputFile(self):
		"""
		Fills the file with the CNF encoding

		This method fills the file with the CNF encoding for the solver to take in as
		an input.

		Raises:
		IOError: If the reading is interrupted, this exception is raised.
		"""
		try:
			with open(self.OutputFile, "w") as oF:
				numVars, numClauses = self._GetNumberOfVariables(), self._GetNumberOfClauses()
				logger.info(f"The CNF encoding contains {numVars} variables and {numClauses} clauses.")
				logger.info(f"Writing CNF to output file: {self.OutputFile}")
				oF.write(f"c ===========================================================================================]\n")
				oF.write(f"c Social Golfers Problem CNF generated by https://github.com/Roiqk7/SocialGolfersProblem.git |\n")
				oF.write(f"c ===========================================================================================]\n")
				oF.write(f"p cnf {numVars} {numClauses}\n")
				with open(self._TmpOutputFile, "r") as tmpF:
					oF.write(tmpF.read())
		except Exception as e:
			logger.error(e)
			raise IOError(f"Could not fill the CNF output file: {e}")

	def _WriteVarID(self):
		"""
		<Short one-line summary>

		<More detailed explanation>

		Args:
		arg1 (type): Description of arg1.
		arg2 (type): Description of arg2.

		Returns:
		type: Description of the return value.

		Raises:
		ExceptionType: Why this exception might be raised.
		"""
		logger.info(f"Writing variables to file: {self._VarIDMapFilePath}")
		# We filter Xes and sort them by id for easier processing later
		xVarItems = [(k, v) for k, v in self._VarIDMap.items() if k[0] == 'X']
		sortedXVarItems = sorted(xVarItems, key=lambda x: x[1])
		with open(self._VarIDMapFilePath, "w") as f:
			for k, id in sortedXVarItems:
				# format: id r p g
				_, r, p, g = k[0], k[1], k[2], k[3]
				f.write(f"{id} {r} {p} {g}\n")

	def _EncodeClauses(self):
		"""
		Calls all the clause generation methods.
		"""
		logger.debug("Encoding clauses...")
		self._EncodeGroupPartitionConstraint()
		self._EncodeGroupSizeConstraint()
		self._EncodeDefinitionOfZ()
		self._EncodePairingConstraint()
		logger.debug("Finished encoding clauses.")

	def _GetVarID(self, var: tuple):
		"""
		Given a variable, returns its ID.

		It is implemented using a simple hash map as there is not that many variables
		even for large inputs.

		Args:
		var (tuple): A variable in the format ('type': char, params: tuple[int])

		Returns:
		int: The variable ID.
		"""
		if var in self._VarIDMap:
			return self._VarIDMap[var]

		newID = self._NextID
		self._NextID += 1
		self._VarIDMap[var] = newID
		return newID

	def _GetNumberOfVariables(self) -> int:
		"""
		Returns the number of variables used in the CNF.

		Since how the ID system works, the last ID - 1 corresponds to the variable count.

		Returns:
		int: Number of variables in the CNF.
		"""
		return self._NextID - 1

	def _GetNumberOfClauses(self) -> int:
		"""
		Returns the number of clauses in the CNF.

		Returns:
		int: Number of clauses in the CNF.
		"""
		return self._ClauseCount

	def _GetClause(self, vars: list[int]) -> str:
		"""
		Given a list of variables, returns the clause in the CNF.

		Simply creates a string with the variable IDs separated by spaces.

		Args:
		vars (list[int]): List of variable IDs.

		Returns:
		str: String representation of the clause.
		"""
		return " ".join(str(x) for x in vars) + " 0\n"

	def _WriteClause(self, vars: list[int]):
		"""
		Writes a clause in the CNF.

		Takes in the list of variable IDs, generates the corresponding clause,
		then writes the clause into the temporary file.

		Args:
		vars (list[int]): List of variable IDs.

		Raises:
		IOError: If the reading is interrupted, this exception is raised.
		"""
		self._ClauseCount += 1
		try:
			with open(self._TmpOutputFile, "a") as f:
				f.write(self._GetClause(vars))
		except Exception as e:
			logger.error(e)
			raise IOError(f"Could not fill the CNF output file {self._TmpOutputFile}: {e}")

	def _EncodeGroupPartitionConstraint(self):
		"""
		Encodes the group partition constraint into DIMACS CNF.

		The constraint is encoded as a combination of "At least one" and "At most one".
		"""
		startTime = clock()
		clauseCount = self._ClauseCount
		logger.debug("Encoding group partition constraint...")
		for r in range(self.R):
			for p in range(self.N):
				Xvars = [self._GetVarID(('X', r, p, g)) for g in range(self.G)]
				# At least one - trivially just write the vars
				self._WriteClause(Xvars)
				# At most one - use helper
				self._EncodeAtMostKConstraint(Xvars, 1)
		logger.debug(f"Finished encoding group partition constraint in {(clock() - startTime):.3f} using {self._ClauseCount - clauseCount} clauses.")

	def _EncodeGroupSizeConstraint(self):
		"""
		Encodes the group size constraint into DIMACS CNF.

		The constraint is encoded only as "at most S" as the "at least S" can be omitted
		thanks to the group partition constraint.
		"""
		startTime = clock()
		clauseCount = self._ClauseCount
		logger.debug("Encoding group size constraint...")
		for r in range(self.R):
			for g in range(self.G):
				Xvars = [self._GetVarID(('X', r, p, g)) for p in range(self.N)]
				self._EncodeAtMostKConstraint(Xvars, self.S)
		logger.debug(f"Finished encoding group size constraint in {(clock() - startTime):.3f} using {self._ClauseCount - clauseCount} clauses.")

	def _EncodeDefinitionOfZ(self):
		"""
		Defined the Z variable used for the pairing constraint.

		The Z variable is defined using this equivalency: Z <=> X1 and X2, and it means
		that a pair of players p1, p2 meet in group g during round r. This heavily
		simplifies the pairing constraint encoding. Also to me it feels more intuitive
		then bruteforcing it only using the X variables.
		"""
		startTime = clock()
		clauseCount = self._ClauseCount
		logger.debug("Encoding definition of Z...")
		for r in range(self.R):
			for g in range(self.G):
				for p1 in range(self.N):
					for p2 in range(p1 + 1, self.N):
						# Z <=> X1 and X2
						Xp1 = self._GetVarID(('X', r, p1, g))
						Xp2 = self._GetVarID(('X', r, p2, g))
						Z = self._GetVarID(('Z', r, p1, p2, g))
						# 1. (Z -> Xp1)
						self._WriteClause([-Z, Xp1])
						# 2. (Z -> Xp2)
						self._WriteClause([-Z, Xp2])
						# 3. (Xp1 AND Xp2 -> Z)
						self._WriteClause([-Xp1, -Xp2, Z])
		logger.debug(f"Finished encoding definition of Z in {(clock() - startTime):.3f} using {self._ClauseCount - clauseCount} clauses.")

	def _EncodePairingConstraint(self):
		"""
		Encodes the pairing constraint into DIMACS CNF.

		Thanks to the Z variables the encoding of this constraint simply reduces to:
		each pair can meet at most T times. Which in my opinion is the natural way to
		think about this constraint.
		"""
		startTime = clock()
		clauseCount = self._ClauseCount
		logger.debug("Encoding pairing constraint...")
		for p1 in range(self.N):
			for p2 in range(p1 + 1, self.N):
				ZvarsForPair = []
				for r in range(self.R):
					for g in range(self.G):
						ZvarsForPair.append(self._GetVarID(('Z', r, p1, p2, g)))
				self._EncodeAtMostKConstraint(ZvarsForPair, self.T)
		logger.debug(f"Finished encoding pairing constraint in {(clock() - startTime):.3f} using {self._ClauseCount - clauseCount} clauses.")

	def _EncodeAtMostKConstraint(self, vars: list[int], K: int):
		"""
		Encodes the constraint that out of N variables only K can be True.

		The way we encode it is the following: The constraint "At Most K are True" is
		equivalent to: "It is NOT True that > K + 1 are True." So for each combination
		of K + 1 variables, we create a clause that forces at least one of them to be
		False by negating all the K + 1 variables.

		Args:
		vars (list[int]): List of variable IDs.
		K (int): How many variables can be True.
		"""
		# Trivial case
		if len(vars) <= K:
			return

		for combo in itertools.combinations(vars, K + 1):
			clause = [-var for var in combo]
			self._WriteClause(clause)
